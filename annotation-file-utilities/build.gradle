import org.gradle.internal.jvm.Jvm

import java.nio.file.Files

plugins {
    // https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow (v5 requires Gradle 5)
    id 'com.github.johnrengelman.shadow' version '5.1.0'
    id 'java'
}
apply plugin: 'java'
apply plugin: 'com.github.johnrengelman.shadow'

group 'org.checkerframework'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}
sourceSets {
    main.java {
        srcDirs =['src', '../scene-lib/src']
    }
    test.java{
        srcDirs += ['../scene-lib/test']
        include("**/AnnotationsTest.java")
        include("**/foo/*.java")
        include("**/AnnotationVerifier.java")
        include("**/TestSceneLib.java")
        include("**/Example.java")
    }
    test.resources {
        srcDirs += ['../scene-lib/test']
        exclude("**/*.java")
    }
}
dependencies {
    implementation 'org.plumelib:bcel-util:1.1.4'
    implementation 'org.plumelib:options:1.0.1'
    implementation 'org.plumelib:plume-util:1.0.7'
    implementation 'org.plumelib:signature-util:0.0.6'
    compileOnly 'org.checkerframework:checker-qual:2.5.4'
    implementation 'org.checkerframework:compiler:2.4.0'
    implementation 'com.google.guava:guava:28.0-jre'
    implementation files('../asmx/bin')

    testCompile group: 'junit', name: 'junit', version: '4.12'
    // Change the JDK via -Dorg.gradle.java.home=JDK_PATH
    testCompile files(Jvm.current().toolsJar)
}
task compileAsmx(type:Exec) {
    workingDir '../asmx'
    executable 'ant'
    args = [
            '-Dproduct.noshrink=true',
            'bin'
    ]
}

compileJava {
    dependsOn compileAsmx
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    options.failOnError = true
    options.deprecation = true
    options.compilerArgs += [
            '-g',
            '-Werror',
            // To not get a warning about missing bootstrap classpath for Java 8 (once we use Java 9).
            "-Xlint:-options",
            "-Xlint:unchecked",
            "-Xlint",
    ]
    options.encoding = 'UTF-8'
}

shadowJar {
    destinationDirectory = projectDir
    archiveVersion = null

    // These appear in annotation-file-utilities-all.jar:
    relocate 'org.apache', 'org.checkerframework.org.apache'
    relocate 'org.relaxng', 'org.checkerframework.org.relaxng'
    relocate 'org.plumelib', 'org.checkerframework.org.plumelib'
    // relocate 'sun', 'org.checkerframework.sun'
    relocate 'org.objectweb.asm', 'org.checkerframework.org.objectweb.asm'
    relocate 'com.google', 'org.checkerframework.com.google'
    relocate 'plume', 'org.checkerframework.plume'
}

test {
    testLogging {
        showStandardStreams = true
        // Always run the tests
        outputs.upToDateWhen { false }

        // Show the found unexpected diagnostics and expected diagnostics not found.
        exceptionFormat "full"
        events "failed"
    }

    // After each test, print a summary.
    afterSuite { desc, result ->
        if (desc.getClassName() != null) {
            long mils = result.getEndTime() - result.getStartTime()
            double seconds = mils / 1000.0

            println "Testsuite: ${desc.getClassName()}\n" +
                    "Tests run: ${result.testCount}, " +
                    "Failures: ${result.failedTestCount}, " +
                    "Skipped: ${result.skippedTestCount}, " +
                    "Time elapsed: ${seconds} sec\n"
        }

    }
}
task testExample(dependsOn: compileTestJava) {
    doLast {
        String testDir = '../scene-lib/test/annotations/tests/executable/'
        javaexec {
            classpath = files(sourceSets.test.java.outputDir)
            classpath += sourceSets.test.compileClasspath
            main = 'annotations.tests.executable.Example'
            standardOutput = new FileOutputStream("${testDir}/example-stdout.jaif")

            args = ["${testDir}/example-input.jaif",
                    "foo.Bar",
                    "${testDir}/example-output.jaif"]
        }
        File outputGoal = new File(testDir, "example-output.jaif.goal");
        File output = new File(testDir, "example-output.jaif");

        byte[] goalJaif = Files.readAllBytes(new File(testDir, "example-output.jaif.goal").toPath());
        byte[] outputJaif = Files.readAllBytes(new File(testDir, "example-output.jaif").toPath());
        if(!Arrays.equals(goalJaif, outputJaif)) {
            throw new GradleException("In ${testDir}, file example-output.jaif does not match goal.")
        }

        byte[] goalStdOut = Files.readAllBytes(new File(testDir, "example-stdout.jaif.goal").toPath());
        byte[] stdOut = Files.readAllBytes(new File(testDir, "example-stdout.jaif").toPath());
        if(!Arrays.equals(goalStdOut, stdOut)){
            throw new GradleException("In ${testDir}, file example-stdout.jaif does not match goal.")
        }
    }
}

task checkBasicStyle(group: 'Format') {
    description 'Check basic style guidelines.  Not related to Checkstyle tool.'

    String[] ignoreDirectories = ['.git',
                                  '.gradle',
                                  '.idea',
                                  '.plume-scripts',
                                  'annotated',
                                  'api',
                                  'bib',
                                  'build',
                                  'jdk',
                                  'asmx',
                                  'javadoc']

    String[] ignoreFilePatterns = [
            '*.aux',
            '*.class',
            '*.dvi',
            '*.eps',
            '*.jaif',
            '*.jar',
            '*.jtr',
            '*.log',
            '*.patch',
            '*.pdf',
            '*.png',
            '*.sty',
            '*.zip',
            '*~',
            '*.goal',
            '*.jaif',
            'CFLogo.ai',
            'logfile.log.rec.index',
            'annotation-file-format.html']

    doLast {
        FileTree tree = fileTree(dir: projectDir)
        for (String dir : ignoreDirectories) {
            tree.exclude "**/${dir}/**"
        }
        for (String file : ignoreFilePatterns) {
            tree.exclude "**/${file}"
        }
        boolean failed = false
        tree.visit {
            if (!it.file.isDirectory()) {
                int isBlankLine
                it.file.eachLine { line ->
                    if (line.endsWith(' ')) {
                        println("Trailing whitespace: ${it.file.absolutePath}")
                        failed = true
                    }
                    if (!line.startsWith('\\') &&
                            (line.matches('^.* (else|finally|try)\\{}.*$')
                                    || line.matches('^.*}(catch|else|finally) .*$')
                                    || line.matches('^.* (catch|for|if|while)\\('))) {
                        // This runs on non-java files, too.
                        println("Missing space: ${it.file.absolutePath}")
                        failed = true
                    }
                    if (line.isEmpty()) {
                        isBlankLine++;
                    } else {
                        isBlankLine = 0;
                    }
                }

                if (isBlankLine > 1) {
                    println("Blank line at end of file: ${it.file.absolutePath}")
                    failed = true
                }

                RandomAccessFile file
                try {
                    file = new RandomAccessFile(it.file, 'r')
                    int end = file.length() - 1;
                    if (end > 0) {
                        file.seek(end)
                        byte last = file.readByte()
                        if (last != '\n') {
                            println("Missing newline at end of file: ${it.file.absolutePath}")
                            failed = true
                        }
                    }
                } finally {
                    if (file != null) {
                        file.close()
                    }
                }
            }
        }
        if (failed) {
            throw new GradleException("Files do not meet basic style guidelines.")
        }
    }
}
